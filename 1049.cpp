/*给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。
例如，给定数列{0.1, 0.2, 0.3, 0.4}，
我们有(0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4)
 这10个片段。
给定正整数数列，求出全部片段包含的所有的数之和。
如本例中10个片段总和是0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。
输入格式：
输入第一行给出一个不超过10^5的正整数N，表示数列中数的个数，第二行给出N个不超过1.0的正数，是数列中的数，其间以空格分隔。
输出格式：
在一行中输出该序列所有片段包含的数之和，精确到小数点后2位。
输入样例：
4
0.1 0.2 0.3 0.4   //所有子集之和 
输出样例：
5.00
分析

这道题开始我用优化了一点的暴力法还是没能解出来，在纸上写了写，最后发现这是道数学题，通过找规律解的。
拿样例举例子：n=4

索引（i）					出现次数	规律
0	0.1	0.1+0.2	0.1+0.2+0.3	0.1+0.2+0.3+0.4	4	(4-0) * (0+1)
1	0.2	0.2+0.3	0.2+0.3+0.4		3+3	(4-1) * (1+1)
2	0.3	0.3+0.4			2+2+2	(4-2) * (2+1)
3	0.4				1	(4-3) * (3+1)
总结：每个数会出现(n - i) * (i + 1)
如果你说，我看不出规律怎么办，那就请你列10个数一步一步写，然后找规律；如果你再看不出来，那就再多列几次，相信一定能找出规律的。

源代码
*/
//C/C++实现
#include <iostream>

using namespace std;

int main(){
    int n;
    scanf("%d", &n);
    double tmp = 0;
    double sum = 0;
    for(int i = 0; i < n; ++i){
        scanf("%lf", &tmp);
        sum += (tmp * (n - i) * (i + 1));
    }
    printf("%.2f\n", sum);
    return 0;
}
