/*给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，
然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，
这个神奇的数字也叫Kaprekar常数。
例如，我们从6767开始，将得到
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174
... ...
现给定任意4位正整数，请编写程序演示到达黑洞的过程。
输入格式：
输入给出一个(0, 10000)区间内的正整数N。
输出格式：
如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，
输出格式见样例。注意每个数字按4位数格式输出。
输入样例1：6767
输出样例1：
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
输入样例2：
2222
输出样例2：
2222 - 2222 = 0000
分析

在这道题中学习到了头文件algorithm中的sort函数，同时也使用了简单的compare方法。
思路大概是：
1.先判断输入的数是否是1111的倍数，如果是，就打印结果并返回零值结束程序；
2.将数值转换成char数组，然后利用sort函数配合compare方法对char数组进行排序，这里也可以使用vector的sort配合reverse反转数组使用，
也是很方便的，然后输出结果，遇到6174就停止即可，这里需要注意的是一定要将6174的判断写在最后，因为输入6174的时候，
还是需要输出一行结果再停止程序的。

遇到的坑：
1.之前对题目的输入一直以为是4位数，但是看过题干后才知道输入是0-10000区间内的正整数，也就是说要对正整数进行处理，
在不足4位整数前补0；
2.char c[4]={'0','0','0','0'};然后println("%s", c);总是出错，问了下朋友才知道，原来要再最后加字符串结束符，
即char[5]={'0','0','0','0','\0'}，之前打印出来总是“烫烫烫烫”。我去，要不要这么烫？

最后科普一下：
1.“烫烫烫”和“屯屯屯”产生自VC，这是debug模式下VC对内存的初始化操作。VC会把栈中新分配的内存初始化为0xcc，
而把堆中新分配的内存初始化为0xcd。把0xcc和0xcd按照字符打印出来，就是烫和屯了。
2.“锟斤拷”，这个是字符编码造成的。在进行从GBK到unicode的转换过程中，部分字符不能转化，
于是unicode给了它们一个特殊的占位符U+FFFD，这个用UTF-8表示就成了\xef\xbf\xbd。
如果出现两个连着的\xef\xbf\xbd\xef\xbf\xbd，按照两个字节一个字显示成汉字，就成了锟斤拷这三个字。
3.“锘”，这个也是由于微软的字符编码造成的，用微软的记事本打开并保存成UTF-8的时候
会在前面加上UTF-8文件的Unicode签名BOM(Byte Order Mark)，在JSP和PHP开发中经常遇到，
微软在自己的UTF-8格式的文本文件之前加上了EF BB BF三个字节，其他文本编辑器会识别此类文件为UTF-8+文件，
然而这个只是微软暗自作的标记, 其它平台上并没有对UTF-8文本文件做个这样的标记。
在文本编辑器中点击保存记得选UTF-8 NO BOM就好了。*/

//C/C++实现
#include <iostream>
#include <algorithm>

using namespace std;

int compare(const int &a, const int &b){
    return a>b;
}

int main(){
    int n;
    scanf("%d", &n);
    if(n % 1111 == 0){
        printf("%d - %d = 0000\n", n, n);
        return 0;
    }
    else{
        int tmp = n;
        while(true){
            char c[5] = {'0','0','0','0','\0'};
            int a, b;
            for(int i = 3; tmp != 0; i--){
                c[i] = (tmp % 10) + 48;
                tmp /= 10;
            }
            sort(c, c + 4, compare);
            a = (c[0] - 48) * 1000 + (c[1] - 48) * 100 + (c[2] - 48) * 10 + (c[3] - 48);
            printf("%s - ", c);
            sort(c, c + 4);
            b = (c[0] - 48) * 1000 + (c[1] - 48) * 100 + (c[2] - 48) * 10 + (c[3] - 48);
            printf("%s = ", c);
            tmp = a - b;
            printf("%04d\n", tmp);
            if(tmp == 6174){
                break;
            }
        }
    }
    return 0;
} 
