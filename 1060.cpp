/*英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数”E，
即满足有E天骑车超过E英里的最大整数E。据说爱丁顿自己的E等于87。
现给定某人N天的骑车距离，请你算出对应的爱丁顿数E（<=N）。
输入格式：
输入第一行给出一个正整数N（<=10^5），即连续骑车的天数；第二行给出N个非负整数，代表每天的骑车距离。
输出格式：
在一行中给出N天的爱丁顿数。
输入样例：
10
6 7 6 9 3 10 8 2 7 8
输出样例：
6
分析

这道题想了好久才用暴力法过了部分测试点，最后还是差一个测试点没法通过，应该是用来卡暴力法的，
起初题意本身都理解不清楚（智商捉急）。
这里简单“翻译”一下：如果E天的骑车公里数均>天数E，那么这个E符合条件，现在可以有很多个E都符合这个条件，
求符合条件的最大值E。
注意：如果输入3 1 2 3。那么结果是1。因为大于1的天数是2天，大于2的天数是1天，大于3的天数是0天，
所以只有E=1满足E天骑车超过E英里，多余的天数可以不算，只要天数>=E即可，不非得是等于。另外在没有符合条件的值是要输出0。
具体的算法是对数组进行降序排序，降序排列的好处是可以直接计算出最大E值。
首先根据样例降序后为：10 9 8 8 7 7 6 6 3 2
1.用10和10的下标1比较，10 > 1，所以有1天的骑车超过1英里；
2.用9和9的下标2比较，9 > 2，所以有2天的骑车超过2英里（因为10 > 9，9符合，所以10肯定符合，后面同理）；
3.用8和8的下标3比较，8 > 3，所以有3天的骑车超过3英里；
4.用8和8的下标4比较，8 > 4，所以有4天的骑车超过4英里；
5.用7和7的下标5比较，7 > 5，所以有5天的骑车超过5英里；
6.用7和7的下标6比较，7 > 6，所以有6天的骑车超过6英里；
7.用6和6的下标7比较，6 > 7不成立，所以最大值E为6。
这里需要注意的是，若全部满足这个条件的话，要检测遍历到数组的结尾就停止，不能越界。

源代码
*/ 
//C/C++实现
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool compare(int a, int b){
    return a > b;
}

int main(){
    int n;
    scanf("%d", &n);
    vector<int> v(n + 1);
    for(int i = 1; i <= n; ++i){
        scanf("%d", &v[i]);
    }
    sort(v.begin() + 1, v.end(), compare); //desc
    int e = 0;
    int i = 1;
    while(i <= n && v[i] > i){
        ++e;
        ++i;
    }
    printf("%d\n", e);
    return 0;
}
