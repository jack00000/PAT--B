/*某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。
这里确保每个输入的日期都是合法的，但不一定是合理的――假设已知镇上没有超过200岁的老人，而今天是2014年9月6日，所以超过200岁的生日和未出生的生日都是不合理的，应该被过滤掉。
输入格式：
输入在第一行给出正整数N，取值在(0, 10^5]；随后N行，每行给出1个人的姓名（由不超过5个英文字母组成的字符串）、以及按“yyyy/mm/dd”（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。
输出格式：
在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。
输入样例：
5
John 2001/05/12
Tom 1814/09/06
Ann 2121/01/30
James 1814/09/05
Steve 1967/11/20
输出样例：
3 Tom John
分析

1.先写定上限和下限，即日期不能晚于2014/09/06，不能早于1814/09/06；
2.然后利用compare方法判断是否为合法日期，如果是合法日期就存入到结构体数组中（结构体：姓名，年，月，日）；
3.再将结构体数组排序，这里我用的是升序，所以开头的即为最年长的，末尾即为最年幼的。

另外再把为合法日期数为1或0考虑进去，即为正确答案。

源代码
*/ 
//C/C++实现
#include <iostream>

using namespace std;

typedef struct information{
    char name[6];
    int year, month, day;
}info;

int compare(const void *a_t, const void *b_t){
    info *a = (info *)a_t, *b = (info *)b_t;
    if(a->year != b->year){
        return a->year - b->year;
    }
    else if(a->month != b->month){
        return a->month - b->month;
    }
    else{
        return a->day - b->day;
    }
}

int main(){
    int n;
    scanf("%d", &n);
    info table[n], first = {"first", 2014, 9, 6}, last = {"last", 1814, 9, 6}; //之后改成n
    int count = 0;
    for(int i = 0; i < n; ++i){
        scanf("%s %d/%d/%d", table[count].name, &table[count].year, &table[count].month, &table[count].day);
        if(compare(&table[count], &first) > 0 || compare(&table[count], &last) < 0){
            continue;
        }
        ++count;
    }
    qsort(table, count, sizeof(table[0]), compare);
    if(count == 1){
        printf("1 %s %s\n", table[0].name, table[0].name);
    }
    else if(count > 1){
        printf("%d %s %s\n", count, table[0].name, table[count - 1].name);
    }
    else{
        printf("0\n");
    }
    return 0;
}

