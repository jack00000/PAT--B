/*“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。
输入格式：
输入第一行给出一个正整数N（<=50000），是已知夫妻/伴侣的对数；随后N行，
每行给出一对夫妻/伴侣――为方便起见，每人对应一个ID号，为5位数字（从00000到99999），
ID间以空格分隔；之后给出一个正整数M（<=10000），为参加派对的总人数；随后一行给出这M位客人的ID，
以空格分隔。题目保证无人重婚或脚踩两条船。
输出格式：
首先第一行输出落单客人的总人数；随后第二行按ID递增顺序列出落单的客人。ID间用1个空格分隔，行的首尾不得有多余空格。
输入样例：
3                  已知夫妻/伴侣的对数
11111 22222
33333 44444
55555 66666
7                   参加派对的总人数
55555 44444 10000 88888 22222 11111 23333
输出样例：
5
10000 23333 44444 55555 88888
分析

真是一道恶趣味的题，不过作为最后一道，难度倒是不大。
1.建立一个伴侣表，用每个人ID作为索引，在其索引下，存放夫妻/伴侣的ID；
举例来讲，若11111和22222互为伴侣，则table[11111]=22222，table[22222]=11111。
2.先把所有参加排队的宾客ID存到数组里面；
3.遍历宾客数组，查找对应伴侣表里面的伴侣是否能在宾客的数组找到，如果找不到，说明是单身狗，将其加入到单身狗的数组里面；
4.遍历宾客数组完成后，对单身狗数组排序（升序）；
5.遍历输出单身狗数组。

注意：ID不足五位的，要用0补位，就这一个坑。

对了，还有，末尾不要输出一个换行符，容易有错。
强迫症是病，得治。

源代码
*/
//C/C++实现
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int table[100000];

int main(){
    int n;
    scanf("%d", &n);
    int a, b;
    for(int i = 0; i < n; ++i){
        scanf("%d %d", &a, &b);
        //建立相互映射关系 
        table[a] = b;
        table[b] = a;
    }
    scanf("%d", &n);
    vector<int> v(n);
    vector<int> doge;
    for(int i = 0; i < n; ++i){
        scanf("%d", &v[i]);
    }
    for(int i = 0; i < n; ++i){
        vector<int>::iterator result = find(v.begin(), v.end(), table[v[i]]);
        if(result == v.end()){ //说明没找到他/她的伴侣 
            doge.push_back(v[i]); //单身狗的队伍又壮大了 
        }
    }
    sort(doge.begin(),doge.end());
    printf("%d\n", doge.size());
    for(int i = 0; i < doge.size(); ++i){
        if(i == 0){
            printf("%05d", doge[i]);
        }        
        else{
            printf(" %05d", doge[i]);
        }
    }
//    printf("\n");
}
